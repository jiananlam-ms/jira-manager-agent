{
  "name": "3. Get Jira Subtasks",
  "nodes": [
    {
      "parameters": {
        "content": "## Get Subtasks\n",
        "height": 240,
        "width": 432,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -544,
        224
      ],
      "typeVersion": 1,
      "id": "73e3de4a-37a9-4761-b27f-522f6906f358",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "content": "## Respond",
        "height": 240,
        "width": 352,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        416,
        0
      ],
      "typeVersion": 1,
      "id": "b278e0d9-4a5e-4478-9bad-18db0db6a242",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "c66d3611-ae74-46dc-b6af-586db935d19c",
              "leftValue": "={{ $items().length }}",
              "rightValue": 1,
              "operator": {
                "type": "number",
                "operation": "gte"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -256,
        304
      ],
      "id": "dee86b48-920e-4dd3-b4ef-f14d7c6c9402",
      "name": "If"
    },
    {
      "parameters": {
        "content": "## Get Details",
        "height": 240,
        "width": 320,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        0,
        0
      ],
      "typeVersion": 1,
      "id": "eb3da7ab-dbf1-4118-badb-e93744b2bc13",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "## Error Response",
        "height": 224,
        "width": 288,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        16,
        464
      ],
      "typeVersion": 1,
      "id": "4fff925c-3727-4d00-90f3-d6c37a6fa87b",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "76186d29-5434-4b9f-befa-f79a9a512c7d",
              "name": "response",
              "value": "This Initiatives does not have any subtasks",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        96,
        544
      ],
      "id": "96464286-82b0-4fda-bf25-185930712008",
      "name": "Error Response",
      "notesInFlow": true
    },
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "story_key"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -800,
        304
      ],
      "id": "82817754-95a1-4307-92ed-fc58c2b6a286",
      "name": "Get Subtasks"
    },
    {
      "parameters": {
        "operation": "get",
        "issueKey": "={{ $json.key }}",
        "additionalFields": {
          "expand": "changelog,transitions",
          "fields": "  project,issuetype,summary,key,created,customfield_10015,duedate,customfield_10267,customfield_10468,customfield_10391,customfield_10392,customfield_10271,status,comment,labels,assignee,timetracking"
        }
      },
      "type": "n8n-nodes-base.jira",
      "typeVersion": 1,
      "position": [
        96,
        80
      ],
      "id": "c4e7156d-8b03-4065-9fd7-34c02de252bf",
      "name": "Get Subtask Details",
      "notesInFlow": true,
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "E5oT7SmDiMCaK5ly",
          "name": "Jian An JIRA"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Configuration ===\nconst DEFAULT_MODE = 'full';\nconst START_DATE_FIELD_ID = 'customfield_10015';\n\n// === STEP 1: Get the selected mode from input ===\nconst mode = $json.mode ?? DEFAULT_MODE;\n\n// === STEP 2: Define all possible fields and their transformation logic ===\nconst fieldDefinitions = [\n  { key: 'key', label: 'Key', path: 'key' },\n  { key: 'title', label: 'Title', path: 'fields.summary' },\n  { key: 'squad', label: 'Squad', path: 'fields.project.name' },\n  { key: 'issuetype', label: 'Type of Issue', path: 'fields.issuetype.name' },\n  { key: 'labels', label: 'Labels', path: 'fields.labels' },\n  { key: 'assignee', label: 'Assignee', path: 'fields.assignee.displayName' },\n  { key: 'original_estimate', label: 'Original Estimate', path: 'fields.timetracking.originalEstimate' },\n  { key: 'created_date', label: 'Created Date', path: 'fields.created', format: 'iso' },\n  { key: 'start_date', label: 'Start Date', path: `fields.${START_DATE_FIELD_ID}`, format: 'iso' },\n  { key: 'end_date', label: 'End date', path: 'fields.duedate', format: 'iso' },\n  { key: 'created_date_formatted', label: 'Created Date (Formatted)', path: 'fields.created', format: 'dd-mmm-yyyy' },\n  { key: 'start_date_formatted', label: 'Start Date (Formatted)', path: `fields.${START_DATE_FIELD_ID}`, format: 'dd-mmm-yyyy' },\n  { key: 'end_date_formatted', label: 'End date (Formatted)', path: 'fields.duedate', format: 'dd-mmm-yyyy' },\n  { key: 'created_date_relative', label: 'Created Date (Relative)', path: 'fields.created', format: 'relative' },\n  { key: 'start_date_relative', label: 'Start Date (Relative)', path: `fields.${START_DATE_FIELD_ID}`, format: 'relative' },\n  { key: 'end_date_relative', label: 'End Date (Relative)', path: 'fields.duedate', format: 'relative' },\n  { key: 'status', label: 'Overall Status', path: 'fields.status.name' },\n  { key: 'last_update_1', label: 'Last Update 1', custom: 'last_update', index: 0 },\n  { key: 'last_update_2', label: 'Last Update 2', custom: 'last_update', index: 1 },\n  { key: 'last_comment_1', label: 'Last Comment 1', custom: 'last_comment', index: 0 },\n  { key: 'last_comment_2', label: 'Last Comment 2', custom: 'last_comment', index: 1 },\n  { key: 'available_transitions', label: 'Available Transitions', custom: 'transitions' },\n];\n\n// === STEP 3: Define which field keys to include for each mode ===\nconst fieldKeysByMode = {\n  full: [\n    'key', 'title', 'squad', 'issuetype', 'labels',\n    'assignee', 'original_estimate',\n    'created_date', 'created_date_relative',\n    'start_date', 'start_date_relative',\n    'end_date', 'end_date_relative',\n    'status',\n    'available_transitions', 'last_update_1', 'last_update_2',\n    'last_comment_1', 'last_comment_2',\n  ],\n  compact: [\n    'key', 'title', 'squad', 'labels',\n    'assignee', 'original_estimate',\n    'start_date', 'start_date_formatted', 'start_date_relative',\n    'end_date', 'end_date_relative',\n    'status',\n    'available_transitions', 'last_update_1', 'last_update_2',\n    'last_comment_1', 'last_comment_2',\n  ],\n  metrics: [\n    'key', 'labels',\n    'assignee', 'original_estimate',\n    'status',\n    'start_date_relative', 'end_date_relative',\n    'available_transitions', 'last_update_1', 'last_update_2',\n    'last_comment_1', 'last_comment_2',\n  ],\n};\n\n// === STEP 4: Utility Functions ===\n\nfunction getNestedValue(obj, path) {\n  return path.split('.').reduce((acc, part) => acc?.[part], obj) ?? null;\n}\n\nfunction normalizeDateString(dateStr) {\n  if (!dateStr || typeof dateStr !== 'string') return dateStr;\n  return dateStr.replace(/([+-]\\d{2})(\\d{2})$/, '$1:$2');\n}\n\nfunction formatDate(dateStr, formatType) {\n  if (!dateStr) return null;\n\n  const normalizedDateStr = normalizeDateString(dateStr);\n  const dateObj = new Date(normalizedDateStr);\n\n  if (isNaN(dateObj.getTime())) {\n    console.error(`Invalid date detected: ${dateStr} (Normalized: ${normalizedDateStr})`);\n    return null;\n  }\n\n  switch (formatType) {\n    case 'iso':\n      return dateObj.toISOString().split('T')[0];\n\n    case 'dd-mmm-yyyy':\n      const day = String(dateObj.getDate()).padStart(2, '0');\n      const monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n      const month = monthNames[dateObj.getMonth()];\n      const year = dateObj.getFullYear();\n      return `${day}-${month}-${year}`;\n\n    case 'relative':\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      const compareDate = new Date(dateObj);\n      compareDate.setHours(0, 0, 0, 0);\n\n      const msInDay = 1000 * 60 * 60 * 24;\n      const diffDays = Math.round((compareDate - today) / msInDay);\n\n      if (diffDays === 0) return \"today\";\n      if (diffDays === 1) return \"tomorrow\";\n      if (diffDays === -1) return \"yesterday\";\n\n      const absDays = Math.abs(diffDays);\n      const label = absDays === 1 ? \"day\" : \"days\";\n      return diffDays < 0 ? `${absDays} ${label} ago` : `in ${absDays} ${label}`;\n\n    default:\n      return dateStr;\n  }\n}\n\n// === STEP 5: Custom Field Logic Helpers ===\n\nfunction getTransitionsValue(transitions) {\n  const validTransitions = transitions ?? [];\n  return validTransitions.length > 0\n    ? validTransitions.map(t => t.name).join(', ')\n    : \"N/A\";\n}\n\nfunction getUpdateValue(sortedHistories, index) {\n  if (!sortedHistories || sortedHistories.length <= index) {\n    return \"N/A\";\n  }\n\n  const history = sortedHistories[index];\n  if (!history.items || history.items.length === 0) {\n    return \"N/A\";\n  }\n  const change = history.items[0];\n\n  const date = formatDate(history.created, 'iso');\n  const fieldName = change?.field ?? 'unknown field';\n  const from = change?.fromString ?? 'N/A';\n  const to = change?.toString ?? 'N/A';\n\n  return `${date}: ${fieldName} changed from '${from}' â†’ '${to}'`;\n}\n\nfunction getCommentValue(comments, index) {\n  const validComments = comments ?? [];\n  const targetIndex = validComments.length - 1 - index;\n\n  if (targetIndex < 0 || validComments.length <= targetIndex) {\n    return \"N/A\";\n  }\n\n  const comment = validComments[targetIndex];\n  const date = formatDate(comment.created, 'dd-mmm-yyyy');\n  const author = comment.updateAuthor?.displayName || comment.author?.displayName || \"Unknown Author\";\n  const body = (comment.body ?? \"[No content]\")\n    .replace(/\\r\\n|\\r|\\n/g, ' ')\n    .replace(/\\[~.*?\\]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n\n  const maxLength = 150;\n  const truncatedBody = body.length > maxLength ? body.substring(0, maxLength) + '...' : body;\n\n  return `${date} by ${author}: ${truncatedBody}`;\n}\n\n// === STEP 6: Core Transformation Logic ===\n\nfunction transformIssue(issue, selectedMode, definitions, keysByMode) {\n  const result = {};\n  const includedKeys = keysByMode[selectedMode] ?? keysByMode[DEFAULT_MODE];\n\n  const comments = issue.fields?.comment?.comments ?? [];\n  const transitions = issue.transitions ?? [];\n  const sortedHistories = (issue.changelog?.histories ?? [])\n    .filter(h => h.items?.length > 0)\n    .sort((a, b) => new Date(normalizeDateString(b.created)) - new Date(normalizeDateString(a.created)));\n\n  for (const field of definitions) {\n    if (!includedKeys.includes(field.key)) continue;\n\n    let value = null;\n\n    try {\n      if (field.custom) {\n        switch (field.custom) {\n          case 'transitions':\n            value = getTransitionsValue(transitions);\n            break;\n          case 'last_update':\n            value = getUpdateValue(sortedHistories, field.index);\n            break;\n          case 'last_comment':\n            value = getCommentValue(comments, field.index);\n            break;\n          default:\n            console.warn(`Unknown custom field type: ${field.custom}`);\n            value = \"Error: Unknown custom type\";\n        }\n      } else {\n        const rawValue = getNestedValue(issue, field.path);\n\n        if (field.format && rawValue !== null) {\n          value = formatDate(rawValue, field.format);\n        } else {\n          value = rawValue;\n        }\n      }\n    } catch (error) {\n      console.error(`Error processing field '${field.label}' (key: ${field.key}):`, error);\n      value = `Error processing field: ${field.key}`;\n    }\n\n    result[field.key] = value;\n  }\n\n  return result;\n}\n\n// === STEP 7: Apply transformation to each input item ===\nconst output = items.map(item => {\n  if (!item.json) {\n    console.error(\"Input item missing 'json' property:\", item);\n    return { json: { error: \"Input item missing 'json' property\" } };\n  }\n  try {\n    return {\n      json: transformIssue(item.json, mode, fieldDefinitions, fieldKeysByMode),\n    };\n  } catch (error) {\n    console.error(\"Error transforming issue:\", item.json?.key || 'Unknown Key', error);\n    return { json: { error: `Failed to transform issue ${item.json?.key || ''}: ${error.message}` } };\n  }\n});\n\n// === STEP 8: Structure and Return the final output ===\n\nfunction getTimestampGMT8() {\n  const now = new Date();\n  try {\n    const formatter = new Intl.DateTimeFormat('en-CA', {\n      year: 'numeric', month: '2-digit', day: '2-digit',\n      hour: '2-digit', minute: '2-digit', second: '2-digit',\n      hour12: false,\n      timeZone: 'Asia/Singapore'\n    });\n    const parts = formatter.formatToParts(now);\n    const dateParts = {};\n    parts.forEach(({type, value}) => { dateParts[type] = value; });\n    return `${dateParts.year}-${dateParts.month}-${dateParts.day}T${dateParts.hour}:${dateParts.minute}:${dateParts.second}+08:00`;\n  } catch (e) {\n    console.warn(\"Intl.DateTimeFormat for timezone formatting failed, using default toISOString().\", e);\n    return now.toISOString();\n  }\n}\n\nconst finalResult = {\n  generation_timestamp: getTimestampGMT8(),\n  total_records: output.length,\n  Subtasks: output.map(item => item.json)\n};\n\nreturn [{ json: finalResult }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        80
      ],
      "id": "481d8cfe-7eb6-42ea-b9ea-240329476545",
      "name": "Transform Subtasks"
    },
    {
      "parameters": {
        "operation": "getAll",
        "returnAll": true,
        "options": {
          "fields": "issuetype,summary,key",
          "fieldsByKey": false,
          "jql": "=project = 10256 AND issuetype = 10007 AND parent = {{ $json.story_key }}"
        }
      },
      "type": "n8n-nodes-base.jira",
      "typeVersion": 1,
      "position": [
        -496,
        304
      ],
      "id": "b92c4564-66e2-4797-86b9-21f83367ca96",
      "name": "List Subtasks",
      "notesInFlow": true,
      "alwaysOutputData": true,
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "E5oT7SmDiMCaK5ly",
          "name": "Jian An JIRA"
        }
      }
    }
  ],
  "pinData": {
    "Get Subtasks": [
      {
        "json": {
          "story_key": "AT-299"
        }
      }
    ]
  },
  "connections": {
    "If": {
      "main": [
        [
          {
            "node": "Get Subtask Details",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Subtasks": {
      "main": [
        [
          {
            "node": "List Subtasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Subtask Details": {
      "main": [
        [
          {
            "node": "Transform Subtasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Subtasks": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "7e846dd1-0691-403a-9acf-e749737cf0fd",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "14df616ca124cf32c43693e6b4cc27d6dbf6b0baaa25603423e96330dcf747f5"
  },
  "id": "35DP7Od2dsM62nCouzPv3",
  "tags": []
}